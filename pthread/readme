
-------------- what about a job queue for POSIX threads ? --------------

WARNING : this is written in plain english without any real worry 
            about precise definitions. 

Consider the possibility of a collection of tasks or jobs that go into a
bucket. We need some way to put the job information into the bucket and
some way to get access to the job information later.  We will also need
the ability to empty the bucket at some point. In the beginning we have
an empty bucket and we should end with an empty bucket once all tasks
are complete.  We shall call this job bucket a "queue".

Things that go into the "queue" are arranged in some sort of order :

    +-------------+      +-------------+      +-------------+
    | job n       | ---> | job ( n+k ) | ---> | job ( n-p ) | --->X
    +-------------+      +-------------+      +-------------+

We could have the "first" job in the queue with some label "job n" and
the next job with some other label "job ( n+k )" where we really do not
care if the numbers "n + k" are greater than, less than, or even the
same as "job n".  In fact the first job in the queue need not even be
job number 1 or job number 0 if you want to be pedantic. The number n
could be a lot larger than zero if once upon a time there existed some
previous jobs that had already been handled. Regardless what we have for
the first value "n" in this list is ordered in that one task somehow
points to the next task in the overall queue list members. I would like
to point out that the list is ordered but the values of "n" need not be
ordered. This may be confusing but what I mean to say is that the number
n could point to some other task that has a number lessor or greater.
This is an "ordered" list of things where the order need not be sorted.
Think of three people standing in line where their names are "Aesop" and
"Marcus Aurelius" and "Sophocles". We have another person show up to
join the line and he is called "Socrates". Thus we now have four people
in line and they are not sorted in alphabetical order for any alphabet
you choose to use. What matters to us is that they are standing a line
and thus there is an obvious order.

If we pick jobs out of the list and handle them in some way then we may
eventually end up with just the last job. That last job will point to
nowhere at all as there are no more jobs. It gets even better in that
we can even have a queue of nothing where there are no jobs at all.

The overall job list is inside a bucket we call a "queue" and the first
order of business we have is to create the queue itself. Which begins
empty. Then we have the elements or task things inside the queue which
up until now we have just called "jobs". These have to be separate "job"
things and they should link to each other in some sort of order. I say
"should" and not really "must" but being organized does make a queue
more easy to deal with.  Same as having a line of people rather than a
crowd of people standing around.  What we really want is a single queue
with an ordered line of "jobs" where there is a head of the line and a
tail end of the line : 

   +------------------------ queue data structure ---------------------+
   |                                                                   |
   |     head --+                                                      |
   |            |                                                      |
   |            v                                                      |
   |  +-------------+      +-------------+      +-------------+        |
   |  | job n       | ---> | job ( n+k ) | ---> | job ( n-p ) | --->X  |
   |  +-------------+      +-------------+      +-------------+        |
   |                                                   ^               |
   |                                                   |               |
   |                                                   +-- tail        |
   |                                                                   |
   +-------------------------------------------------------------------+

How do we program this for a computer?

Lets consider a data structure thing that shall be our queue and we can
call it "q_type" which means a "queue data type" thing. It shall have a
few pointers inside it for the "head" and "tail" of the list and those
pointers shall be to queue items we shall call q_item types : 


    typedef struct q_type {

       /* We need a thing here which is 
        * the top or "head" of the list.
        * This is a pointer to the first item
        * in the line up of jobs. */

        struct q_item *head;

       /* The end of the whole list will 
        * also exist as the "tail". */

        struct q_item *tail;

       /* It is nice to have a counter somewhere
        * to tell us how many things are in the queue */

        int length;

       /* We need a way to control access to
        * this list from many places and protect
        * us from multiple accesses happening at
        * the same time. Essentially protect us
        * from data corruption or inconsistent
        * queue elements.  This is called a mutual
        * exclusion lock. */ 

        pthread_mutex_t q_mutex;

        /* Is this queue live or dead?
         *
         * Here I am thinking that someday and someway
         * we need to have consumers or workers out there
         * that check if there is jobs in the queue as
         * well as a way to signal that we are shutting
         * down the whole queue. The other neat feature we
         * get from a POSIX thread condition variable is 
         * that we can signal to waiting workers that a
         * job has arrive in the queue.
         */
        pthread_cond_t alive;

    } q_type;


The above thing is actually the job queue. However we need a thing to
put in the queue. A task. A job.  A thing that somehow contains the data
we need that describes a job to do.  This must be a data type that we
can point to in the queue "head" and "tail" pointers. Thus it is a data
type called the "q_item" which clearly is an item in the queue.


    typedef struct q_item {

        /* We need a way to stuff a data payload or 
         * parameter information load in this thing.
         * Here we want a pointer that can be used to
         * point to anything anywhere. It does not have
         * a specific data type. Thus a "void" pointer
         * works great as it merely contains a memory
         * address than can point to anything.
         */

        void *payload;

        /* Is there a next item in the list ? */

        struct q_item *next;

    } q_item;


We need some way for the queue thing to exist in memory somewhere. Since
everything in the C programming language boils down to accessing and 
manipulating stuff in memory somehow then we need a way for the queue to
exist in memory. Any variable we use will either be in some automatic
memory location which resides in a thing called a "memory stack" or it
may be a memory location that we have to ask for seperately and that is
called a big "memory heap".  Just know that we have to have the queue in
memory to do anything with it. [1]


I think it is best to have a way to setup the queue in memory as well as
a way to tear it down and remove it from memory.  For now we just want
to setup the queue thing in memory somewhere.  For that we can talk in
general terms with "pseudocode" : 


    make_a_queue () {

        request for a queue object thing in memory

        check that the request for memory actually worked

        make sure "head" points to nowhere

        make sure "tail" also points nowhere

        be sure the magic mutex thing exists and is setup somehow

        return the shiney new queue to whomever

    }


This new function will have to return an object which has a data type
called the "q_type":


    q_type *q_create() {

        /* make a request for a queue thing in memory and
         * for extra special fun we want that memory to be
         * "clear".  That means all zeros in it. For this we
         * need one number element of a "struct q_type" thing.
         */

        struct q_type *q = calloc( (size_t) 1, (size_t) sizeof(struct q_type));

        /* Make sure "head" and "tail" exist and 
         * since the queue is empty we want them both to 
         * be NULL pointers that point to nowhere. 
         *
         * Special note : we already asked above that the
         * memory be all set to zero and so this really is
         * not needed.  We do it anyways for clarity reasons.
         */
         q->head = NULL;
         q->tail = NULL;

        /* we know that the length of this queue is zero and
         * again we already asked for clean memory that is all
         * zeros but lets do this for clarity. */
        q->length = 0;

        /* be sure the mutex thing exists and is setup as an
         * initialized POSIX thread mutual exclusion lock
         * based on the macro PTHREAD_MUTEX_INITIALIZER
         *
         * from the manual page for pthread_mutex_init(3C) :
         *
         *     In cases where default mutex attributes are
         *     appropriate, the macro PTHREAD_MUTEX_INITIALIZER
         *     can be used to initialize mutexes that are
         *     statically allocated. The effect is equivalent to
         *     dynamic initialization by a call to pthread_mutex_init()
         *     with parameter attr specified as NULL, except that
         *     no error checks are performed.
         */
        q->q_mutex = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;

        /* setup the alive thread condition */
        q->alive = (pthread_cond_t)PTHREAD_COND_INITIALIZER;

        /* return the shiney new empty queue */
        return q;

    }


We now have a way to create a queue thing in memory and we even get back
a totally clear queue thing. What is the very first thing we will want
to do with a shiney new empty queue?  How about we put a "job" type
thing into it?

At this time we should think about what type of a queue are we dealing
with?  For the sake of being real simple I am thinking of a FIFO queue
where stuff gets put into it and also taken out of in order. We do not
just randomly toss stuff into the queue nor do we randomly take stuff
out. Whatever goes in is always going to be the "tail" of a list of
things and then new stuff may be put in after. The First stuff In is
also the First stuff Out.  This is FIFO queue type order.


We need a function that somehow puts a thing into the queue : 


    magic_stuff_it_in_queue ( gimme a queue,
                              gimme job information payload ) {

        first we need to protect the queue from other processes or
           other code wrangling with it.  Use the mutex lock.

        we have been given some sort of job payload information and
          it now needs to get stuffed into the queue. We will need
          to create a new queue item thing and load it with the new
          job information "payload".

        is the queue list empty?

            yes : then this is a new job to be put into a new
                  queue where the head and tail of the queue
                  are currently pointing nowhere.

            no  : this is a new job to be added into the existing
                  queue list at the "tail".

        we can now remove the protection from the queue as we have
           finished wrangling the contents inside it
   
        return back the number of items in the queue

    }


Lets try to write that in the C programming language where we say that
we are putting something onto the head of the queue :


    int enqueue ( q_type *q, void *p ) {

        /* set the mutex as locked */
        pthread_mutex_lock ( &( q->q_mutex ) );

        /* we need to create a new queue item and put
         * the payload into it */

        struct q_item *new_item = calloc((size_t) 1,
                                         (size_t)sizeof(struct q_item));

        new_item->payload = p;

        /* we used calloc to give us clear memory but to be 
         * more obvious this item points to nowhere at the moment */
        new_item->next = NULL;

        /* Is the queue list empty? Check if head and tail
         * point nowhere and even check if length is zero.
         *
         * To be clear the queue itself is NOT a linked 
         * list but rather the items inside it are linked.
         *
         * If the queue is empty then the head points to
         * nowhere as well as the tail. The length will
         * also be zero.  If there is only a single item
         * in the queue then the head and tail both point
         * to that single item. */

        if (   ( (q->length) == 0    )
            && ( (q->head)   == NULL )
            && ( (q->tail)   == NULL ) ) {

            /* the queue is indeed empty.
             *
             * Just place the new_item on the head and
             * the tail also is the same item and then
             * set the length to one.
             */
            q->head = new_item;
            q->tail = new_item;
            q->length = 1;

        } else {

            /* The queue is not empty.
             *
             * Take this new_item and stick it on the queue
             * tail. However we already have something on
             * the tail and we need to preserve that pointer.
             * Therefore whatever is on the tail now must
             * point to the new_item. Also the queue tail
             * will point to this new_item as it really is
             * now on the end of the list. 
             *
             *   +-------------- queue ----------------+
             *   |                                     |
             *   |   length =   3                      |
             *   |                                     |
             *   |   head ----+                        |
             *   |            |                        |
             *   |            V                        |
             *   |     +----- some_item_N ---------+   |
             *   |     |                           |   |
             *   |     |    payload = a_pointer_x  |   |
             *   |     |                           |   |
             *   |     |    next -----+            |   |
             *   |     |              |            |   |
             *   |     +------------  |  ----------+   |
             *   |                    |                |
             *   |                    V                |
             *   |     +----- some_item_P ---------+   |
             *   |     |                           |   |
             *   |     |    payload = a_pointer_y  |   |
             *   |     |                           |   |
             *   |     |    next -----+            |   |
             *   |     |              |            |   |
             *   |     +------------  |  ----------+   |
             *   |                    |                |
             *   |                    |                |
             *   |   tail ----+       |                |
             *   |            |       |                |
             *   |            V       V                |
             *   |     +----- some_item_X ---------+   |
             *   |     |                           |   |
             *   |     |    payload = a_pointer_z  |   |
             *   |     |                           |   |
             *   |     |    next ---> NULL         |   |
             *   |     |                           |   |
             *   |     |      This "next" is also  |   |
             *   |     |      queue->tail->next    |   |
             *   |     |                           |   |
             *   |     +---------------------------+   |
             *   |                                     |
             *   +-------------------------------------+
             *
             */
            q->tail->next = new_item;
            q->tail = new_item;
            q->length += 1;

        }

        /* unlock the mutex */
        pthread_mutex_unlock ( &( q->q_mutex ) );

        /* send out a signal to at least one thread consumer
         * which may be waiting. No promise anything is actually
         * waiting but if there is then we signal that a new
         * job has arrived.
         *
         * From the manpage : 
         *
         *    The pthread_cond_signal() call unblocks at least one
         *    of the threads that are blocked on the specified
         *    condition variable.
         *
         *    This is if any threads are blocked.
         *
         */
        pthread_cond_signal( &( q->alive ) );

    }


How do we get anything out of that job list queue? 

Good question. We have to talk about a "consumer" thingy idea that 
eats up the jobs in the job queue. A consumer does what you think. It
goes looking for something to "eat" and if it finds something it then
"eats" the job up.  As far as the queue is concerned the problem is out
of its hands.  We can get to consumer eating stuff later but for now
be able to get something from the queue.


    get_job_thing ( some queue ) {

        protect the queue from all other threads accessing it 

        check if the queue is empty ?
            we want to get a job out of the queue but there is 
            nothing for us. We need to check the queue condition
            as being alive or dead.  This is where we await a
            signal that tells us the queue is good to go.

        If we had to wait for a signal then we are now fine and good
          because we definately have a job that we can get from the
          queue.

        get a job item from the head of the queue. This is a FIFO which
          means that the first job that went into the queue is also
          the first job we take out.

        remove the protection

        return the task payload thing

    }


Great. Now lets translate that into some sort of valid C code where
the objective is to remove a job from the head of the queue :


    void *dequeue( q_type *q ) {

        void *return_payload = NULL;

        /* We only care about the first job in the queue and
         * we want the payload from that first job. Looking
         * at this diagram we see queue->head->payload is what
         * we want. 
         *
         *   +--------- queue -----------+
         *   |                           |
         *   |   head -->  some_item_N   |
         *   |                           |
         *   |   tail -->  some_item_X   |
         *   |                           |
         *   |   length =   3            |
         *   |                           |
         *   +---------------------------+
         *
         *   However the some_item_N looks like :
         *
         *   +----- some_item_N ---------+
         *   |                           |
         *   |    payload = a_pointer_x  |
         *   |                           |
         *   |    next ---> some_item_P  |
         *   |                           |
         *   +---------------------------+
         *
         * Once we get queue->head->payload then the job that
         * was called "some_item_N" no longer needs to exist.
         * The queue head must now point to whatever some_item_N
         * was pointing to as "next". That could even be NULL.
         */

        /* protect the queue from all other threads accessing it */
        pthread_mutex_lock ( &( q->q_mutex ) );

        /* check if the queue is empty and wait until it is alive */
        while ( ( (q->length) == 0 )
                && ( (q->head) == NULL )
                && ( (q->tail) == NULL ) ) {
        
            /* queue is empty so we await for it to get a task */
            pthread_cond_wait( &( q->alive ), &( q->q_mutex ) );

        }

        /* we now know for certain that the queue has something
         * at the head.  So get the payload that is pointed to. */
        return_payload = q->head->payload;

        /* redirect the head of the queue to point to whatever
         * was the next item, HOWEVER we need to save the 
         * current pointer data to free() the memory later */
        q_item *tmp=q->head;
        q->head = tmp->next;
        q->length -= 1;

        /* did we just empty the queue of the only item? */
        if ( ( q->length == 0 ) && ( q->head == NULL ) ) {
            q->tail = NULL;
        }

        /* unlock the mutex */
        pthread_mutex_unlock ( &( q->q_mutex ) );

        /* free up the memory that was being used by the item
         * we just took the payload from */
        free(tmp);
        tmp = NULL;


        return ( return_payload );
         
    }


Footnote : 

    [1] "The C Programming Language", 2nd Ed, Brian W. Kernighan,
        Dennis Ritchie, page 31 section 1.10 "External variables and
        Scope"






------------------------------------------------------------------------
123456789+123456789+123456789+123456789+123456789+123456789+123456789+12

    W A R N I N G :    e v e r y t h i n g     b e l o w    i s   j u s t 
                      
                             e x t r a     i n f o

                                     a b o u t   v a l g r i n d



len$   
len$ valgrind -s --leak-check=full --leak-check=full --show-leak-kinds=all ./q_work 4
==2993== Memcheck, a memory error detector
==2993== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==2993== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==2993== Command: ./q_work 4
==2993== 
-------------------------------------------------------------
           system name = Linux
             node name = lenovo
               release = 5.5.10-genunix
               version = #1 SMP Wed Mar 18 21:54:50 GMT 2020
               machine = x86_64
             page size = 4096
          avail memory = 5819428864
                       = 5683036 kB
                       = 5549 MB
                endian = little endian
 sizeof(unsigned long) = 8
           sizeof(int) = 4
         sizeof(void*) = 8
     fp rounding mode is FE_TONEAREST
-------------------------------------------------------------
INFO : num_pthreads is 4
INFO : about to call q_create()
DBUG : my_q now exists at 0x4b87500

INFO : q_push(make_work) done
     : my_q->length = 1

INFO : q_push(make_work) done
     : my_q->length = 2

INFO : q_push(make_work) done
     : my_q->length = 3

INFO : q_push(make_work) done
     : my_q->length = 4

     : about to call q_destroy(my_q)
     : q_destroy(my_q) says 0 items were thrown away
==2993== 
==2993== HEAP SUMMARY:
==2993==     in use at exit: 33,555,584 bytes in 12 blocks
==2993==   total heap usage: 19 allocs, 7 frees, 33,556,840 bytes allocated
==2993== 
==2993== 64 bytes in 4 blocks are still reachable in loss record 1 of 3
==2993==    at 0x4838B65: calloc (vg_replace_malloc.c:762)
==2993==    by 0x109917: main (q_work.c:108)
==2993== 
==2993== 1,088 bytes in 4 blocks are possibly lost in loss record 2 of 3
==2993==    at 0x4838B65: calloc (vg_replace_malloc.c:762)
==2993==    by 0x4011661: allocate_dtv (dl-tls.c:286)
==2993==    by 0x4011FAD: _dl_allocate_tls (dl-tls.c:532)
==2993==    by 0x4865C0E: allocate_stack (allocatestack.c:622)
==2993==    by 0x4865C0E: pthread_create@@GLIBC_2.2.5 (pthread_create.c:662)
==2993==    by 0x109AC4: main (q_work.c:144)
==2993== 
==2993== 33,554,432 bytes in 4 blocks are still reachable in loss record 3 of 3
==2993==    at 0x4838B65: calloc (vg_replace_malloc.c:762)
==2993==    by 0x109C22: do_some_array_thing (q_work.c:195)
==2993==    by 0x4864F26: start_thread (pthread_create.c:479)
==2993==    by 0x4ABF2EE: clone (clone.S:95)
==2993== 
==2993== LEAK SUMMARY:
==2993==    definitely lost: 0 bytes in 0 blocks
==2993==    indirectly lost: 0 bytes in 0 blocks
==2993==      possibly lost: 1,088 bytes in 4 blocks
==2993==    still reachable: 33,554,496 bytes in 8 blocks
==2993==         suppressed: 0 bytes in 0 blocks
==2993== 
==2993== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)


Note that memory pressure is a very real thing and we can manage
some of that on Linux with : 

titan$ cat /proc/meminfo | grep -i 'commit'
CommitLimit:     6077292 kB
Committed_AS:      81192 kB
titan$ sysctl vm.overcommit_memory
vm.overcommit_memory = 0
titan$ sysctl vm.overcommit_ratio
vm.overcommit_ratio = 50
titan$ sysctl vm.overcommit_kbytes
vm.overcommit_kbytes = 0
titan$ wc -l /etc/sysctl.conf
68 /etc/sysctl.conf
titan$ sysctl -p  ^C
titan$ 
titan$ sysctl -w vm.overcommit_memory=1  ^C
titan$ 

see https://www.kernel.org/doc/html/v5.4/vm/overcommit-accounting.html


titan# 
titan# sysctl vm.overcommit_memory
vm.overcommit_memory = 0
titan# sysctl -w vm.overcommit_memory=1 
vm.overcommit_memory = 1
titan# sysctl vm.overcommit_memory
vm.overcommit_memory = 1
titan# cat /proc/meminfo | grep -i 'commit'
CommitLimit:     6077292 kB
Committed_AS:      79572 kB
titan# 
